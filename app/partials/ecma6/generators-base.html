<p>
	Generators allow us different way of iteration through our collections of data.
</p>
<ul>
	<li>When calling generator first <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator" target="_blank">Iterator object</a> is returned.</li>
	<li id="iterators" ng-class="{focused:iterators}">Calling .next() on iterator object we are calling generator. It returns object with two properties back
		<ul>
			<li>'value' property contains what was 'yielded' back</li>
			<li>'done' is boolean which indicates if there is some data still</li>
		</ul>
	</li>
</ul>
<div id="for-of-generators" ng-class="{focused:forOfGenerators}">
<h4>for..of</h4>
<p>To use custom iterators we use for..of. JavaScript Object doesn't have default iterator (array, string and map do have one)</p>
<pre>
var myArray = [9, 8, 7];
for (let i in myArray) {
	AppLogger.info(i);
}

for (let i of myArray) {
	AppLogger.info(i);
}
</pre>
</div>
<h4>Creating your own generator</h4>
<pre>
var students = [
	{
		id : 1,
		privateData : {
			name : 'Slaven',
			lastName : 'Tomac'
		}
	},
	{
		id : 2,
		privateData : {
			name : 'Slavko',
			lastName : 'Tomak'
		}
	},
	{
		id : 3,
		privateData : {
			name : 'Sly',
			lastName : 'Tom'
		}
	}
];

function* studentsIterator(students) {
	for (var student of students) {
		if (student.id % 2 === 0) {
			yield [student.id, student.privateData.name]	
		}
	}
}

for (var [id, name] of studentsIterator(students)) {
	AppLogger.info(id + ' - ' + name);
}
</pre>
<h4>Using your generator</h4>
<pre>
var iterator = studentsIterator(students);
AppLogger.info(iterator.next());
AppLogger.info(iterator.next());
AppLogger.info(iterator.next());
AppLogger.info(iterator.next());
</pre>
