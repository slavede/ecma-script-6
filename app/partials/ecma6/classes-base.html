<p>Replacement for prototype-based inheritance</p>
<ul>
	<li>To create a class you should use keyword 'class'</li>
	<pre>
class Vehicle {
	</pre>
	<li>Reserved word 'constructor' for constructor. Only one per class.</li>
	<pre>
	constructor(color, numberOfWheels) {
		this.vehicleColor = color;
		this.numberOfWheels = numberOfWheels;
	}
	</pre>
	<li>Allows creation of static methods (they are not in prototype)</li>
	<pre>
	static minimumWheels() {
		return 2;
	}
	</pre>
	<li>Accessor properties</li>
	<pre>
	// accessor properties
	get color() {
		return this.vehicleColor;
	}

	set color(color) {
		this.vehicleColor = color;
		return this.vehicleColor;
	}
	get wheels () {
		return this.numberOfWheels;
	}
	</pre>
	<li>Public methods (all of them are placed in protototype) can be string keyed</li>
	<pre>
	makeASound () {
		return "I'm unknown vehicle. Don't know how."
	}



	"string keyed method"() {
		return "String Keyed Method"
	}
}
	</pre>
	<li>To inherit from another class you should use 'extends' keyword. Call parent functions with super.method_name</li>
<pre>
class Bicycle extends Vehicle{
	constructor(color) {
		super(color, 2);
	}
}
</pre>
</ul>

<pre>
AppLogger.info(Vehicle.prototype.makeASound !== undefined);
AppLogger.info(Vehicle.prototype["string keyed method"] !== undefined);
AppLogger.info(Vehicle.prototype.minimumWheels === undefined);

AppLogger.info(Vehicle.minimumWheels !== undefined);

var vehicle = new Vehicle('red');

AppLogger.info(vehicle.color);
AppLogger.info(vehicle.vehicleColor);
vehicle.color = 'blue';
AppLogger.info(vehicle.color);
AppLogger.info(vehicle.vehicleColor);

AppLogger.info(vehicle["string keyed method"]());

var bicycle = new Bicycle('black');
AppLogger.info(bicycle.wheels);
AppLogger.info(bicycle.color);

bicycle.color = 'pink';
AppLogger.info(bicycle.color);
</pre>